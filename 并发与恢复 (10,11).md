## 恢复技术

### 事务

- 原子性：要么都做要么都不做
- 一致性：数据库中只包含事务成功提交的结果
- 隔离性：一个事务的执行不能被其他事务干扰
- 持续性：事务提交的改变是永久的

### 故障恢复

- 事务故障：undo 已完成的事务
  - 反向扫描日志文件，查找更新操作
  - 对该事务的更新操作执行逆操作
  - 当读到事务的开始标记时停止
- 系统故障：undo 未完成的事务，redo 已完成的事务
  - 正向扫描日志文件，建立 redo、undo 队列
    - redo 队列：故障发生前已提交的事务
    - undo 队列：故障发生时还未完成的事务
  - 反向扫描日志，对 undo 事务执行逆操作
  - 正向扫描日志，重做 redo 事务
- 介质故障：重装数据库，redo 已完成的事务
  - 装入最新的后备数据库副本，使数据库恢复到最近一次转储的一致性状态
  - 装入有关日志文件副本，重做已完成事务
    - 扫描日志文件，找到故障发生前已提交的事务，加入 redo 队列
    - 正向扫描日志文件，重做 redo 事务

### 检查点

- 重新开始文件：记录检查点地址
- 恢复策略
  - 从重新开始文件中找到最后一个检查点记录在日志文件中的地址
  - 读取检查点记录，获取检查点时活动事务清单 active_list，将 active_list 放入 undo 队列
  - 从检查点开始正向扫描日志
    - 若新的事务开始，则加入 undo 队列
    - 若事务结束，则移入 redo 队列
  - 反向扫描日志，对 undo 事务执行逆操作
  - 从检查点开始正向扫描日志，重做 redo 事务



## 并发控制

- 封锁类型

  - 排他锁（X 锁）：只允许当前事务读写

  - 共享锁（S 锁）：只允许当前事务读，允许其他事务加 S 锁
- 封锁协议

  - 一级：防止丢失更新（读取到未被更新的数据）
    - 修改数据前加 X 锁，事务结束时释放
  - 二级：防止读脏数据（读到被撤销之前的数据）
    - 读取数据前加 S 锁，读完就释放
  - 三级：防止不可重复读（第二次读取之前已被更新）
    - 读取数据前加 S 锁，事务结束时释放
  - 死锁（互斥、不可抢占、部分分配、环路）
    - 超时法，等待图法
    - 选择代价最小的事务撤销
- 可串行化调度：与某一串行执行的结果相同
  - 充分条件：冲突可串行化（交换不冲突操作使得调度是串行的）
  - 两段锁协议：对任何数据读写时首先要封锁，在释放一个锁后不能再获得其他锁
    - 任何一个调度都可串行化
    - 可能思死锁

  - 一次封锁法


